# $Id$

		      THE PIRATE GUIDE

		   understanding the code
	       even if you don't know python



#################

RUNNING THE TESTS

#################

   The first thing to do is run the tests. If everything
   is working, it looks like this:

   % python PirateTest.py
   .......................
   --------------------------------------------
   Ran 23 tests in 1.354s

   OK


   (where 23 is however many tests there are)

   If the tests aren't working on a fresh install of
   pirate and parrot, it either means:

       - something in parrot has changed 
       - someone checked in code that didn't pass the tests. 
       - your python compiler package is incompatible with mine
         (2.3 is latest python, I'm using 2.2)

   But, hopefully it's working and we can move on. :)

   Now look inside PirateTest.py ... You'll see there's
   a utility function called trim() (nice for indenting 
   multi-line strings in python code) and then a class 
   called PirateTest with a bunch of test_xyz methods. 

   Each of these methods calls self.run() on a chunk of
   python code. run() compiles the code and invokes parrot
   to see what the code does. Once we have the output, we 
   assert what the result should be. If the assertion holds
   true, you get a dot when you run the tests. If the 
   assertion fails, you'll get a traceback instead. For
   example, if I break test_print so that it looks like this:

    def test_print(self):
        res = self.run(
            """
            print 'hello,',
            print 'world!'
            """)
        self.assertEquals(res, "it's broke!\n")

   Then the tests show something like this:


..............F.........
======================================================================
FAIL: test_print (__main__.PirateTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "PirateTest.py", line 47, in test_print
    self.assertEquals(res, "it's broken!\n")
  File "/usr/local/lib/python2.2/unittest.py", line 286, in failUnlessEqual
    raise self.failureException, \
AssertionError: 'hello, world!\n' != "it's broken!\n"

----------------------------------------------------------------------
Ran 23 tests in 1.443s

FAILED (failures=1)


    Yuck. So keep the tests running! :)



####################################

THE PIRATE CODE GENERATOR FOR PYTHON

####################################

    Because so many languages have similar control structures,
    the plan is to eventually have a generic code generator 
    that compilers for other languages can talk to. But for 
    now, the code generator is python-specific.

    If you open pirate.py and scroll through, you will see that
    most of the file is one huge class called PirateVisitor and
    it has a bunch of visitXxxxx and yyyyExpression methods.

    This class is meant to be used by the python compiler package.
    The compile() function near the bottom of the file returns a 
    tree-like structure (called "ast" for abstract syntax tree) 
    and we instantiate a PirateVisitor to walk through it.

             NOTE: See Klaas-Jan Stol's report for an in-depth look
                   at how parsers and ASTs and compilers in general
                   work. His report is about Lua->Parrot but most of it 
                   applies to python too:

                   http://members.home.nl/joeijoei/parrot/report.pdf


    All the work of building the AST gets done in python's parser 
    and compiler packages. We just walk the tree for each node, 
    call the appropriate  method our PirateVisitor instance. The
    PirateVisitor builds up a list of strings, where each string
    is a line of parrot code.

    Each visitXxxx methods correspons to a keyword or operator in 
    the python language, and contain templates for generating the
    corresponding parrot code.

    Let's look at two examples.

    First, find the "visitPrint" method in pirate.py. You will see 
    that visitPrint calls the __py__print routine (which is written
    in parrot and found in the file pirate.imc )... No big deal.

    Now find "visitWhile". This one is a template for a "while" loop
    and is slightly more complex. 

    In fact, the code is a little hard to read. Currently there's a 
    lot of list-appending and string interpolation going on, so 
    these templates can be a little messy. It might help to just
    try it out. Create a simple python file like this:

            while 1:
               pass

    Save that as while.py and run this:

    ./pirate.py -d while.py

    The -d option tells pirate to dump out the source code. Unless
    visitWhile() has been improved, this should print:

        .sub __main__
            new_pad 0
            setline 1                     # (set_lineno:82)
        while0:
            $P0 = new PerlInt             # (visitWhile:473)
            $P0 = new PerlInt             # (expressConstant:154)
            $P0 = 1                       # (expressConstant:155)
            unless $P0 goto endwhile0     # (visitWhile:475)
            noop                          # (visitPass:549)
            goto while0                   # (visitWhile:477)
        endwhile0:
            end                           # (compile:596)
        .end
        .include 'pirate.imc'

     Which, if you ran it through parrot, would loop forever. :)

     Let's look a little closer at the generated code.

     The comments on the right indicate which method and line
     in the *compiler* resulted that particular line of code.
     (The extra "new" is a bug, and yes, we're using PerlInt 
     for now.)

     You'll notice the labels all end with 0. That's a product 
     of PirateVisitor.symbol(), which appends a unique number 
     to a string so we don't get a bunch of symbol clashes in 
     code we pass to IMC.  (No good saying "goto endwhile"
     if there's 50 while loops in the code)

     BTW, you can also dump the code that each of the test cases uses. 
     Most of the tests pass dump=0 to self.run (and if one doesn't,
     you can add it in). Change the 0 to 1 and you'll see the code.
     The other parameter, lines, will show line numbers for the IMC
     code -- helpful if imcc gives you a nasty  message about something 
     on line 23. :)


     Okay, moving back to pirate.py: the other major thing to look 
     at in PirateVisitor is the expression() and various .xxExpression() 
     (soon to be expressXXXX) methods. 

     As the expression() docstring explains, standard python uses
     a stack-based machine, so the standard bytecode just push and
     pop values on and off a stack. In pirate, we use registers
     instead, so when we visit an expression we have to pass in
     a destination register, telling parrot where to store the 
     value. The expression() method takes care of this, and you'll
     notice these methods all have a "dest" parameter.

     About the only other tricky thing right now is PirateSubVisitor. 
     This is actually just a subclass of PirateVisitor, so it can
     do anything the normal visitor does. The only difference is that
     when .genCode() (which returns the IMC code) finally gets called,
     it adds some code to handle the parrot calling conventions.

     PirateSubVisitor is used for lambdas and subroutines. It works
     exactly the same as PirateVisitor except the generated code is
     just a little bit different. The main PirateVisitor invokes
     PirateSubVisitor whenever it sees a "lambda" or "def" statement,
     collects the generated code in a separate list called self.subs.

     Anyway, that's all for now. Hopefully it'll  get you started 
     working with Pirate. :)


